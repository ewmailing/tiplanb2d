/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package org.box2d.box2d;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollProxy;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.titanium.TiC;
import org.appcelerator.titanium.util.Log;
import org.appcelerator.titanium.util.TiConfig;
import org.appcelerator.titanium.util.TiConvert;
import org.appcelerator.titanium.proxy.TiViewProxy;
import org.appcelerator.titanium.view.TiCompositeLayout;
import org.appcelerator.titanium.view.TiCompositeLayout.LayoutArrangement;
import org.appcelerator.titanium.view.TiUIView;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import android.app.Activity;
import android.view.View;
import android.os.Handler;

import com.badlogic.gdx.physics.box2d.World;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.FixtureDef;
import com.badlogic.gdx.physics.box2d.Shape;
import com.badlogic.gdx.physics.box2d.CircleShape;
import com.badlogic.gdx.physics.box2d.PolygonShape;

import org.box2d.box2d.BodyProxy;


import co.lanica.platino.ColanicaplatinoGameView;
import co.lanica.platino.PlatinoSprite;
import co.lanica.platino.proxy.GameViewProxy;
import co.lanica.platino.proxy.SceneProxy;
import co.lanica.platino.proxy.SpriteProxy;

// This proxy can be created by calling Box2d.createBox2dWorld({message: "hello world"})
@Kroll.proxy(creatableInModule=Box2dModule.class)
public class Box2dWorldProxy extends TiViewProxy
{
	// Standard Debugging variables
	private static final String LCAT = "Box2dWorldProxy";
	private static final boolean DBG = TiConfig.LOGD;
	private static final float PTM_RATIO = 16; // magic number from iOS version

	private World theWorld;
	private GameViewProxy theSurface;
	private Box2dWorld worldView;
	private ArrayList listOfBodies;
	private Handler ticksTimer;

	private class Box2dWorld extends TiUIView
	{
	// Standard Debugging variables
//	private static final String LCAT = "Box2dWorld";
//	private static final boolean DBG = TiConfig.LOGD;

		public Box2dWorld(TiViewProxy proxy) {
			super(proxy);
		Log.d(LCAT, "Box2dWorld constructor " + proxy);
			
//			theSurface = proxy;
			LayoutArrangement arrangement = LayoutArrangement.DEFAULT;

			if (proxy.hasProperty(TiC.PROPERTY_LAYOUT)) {
				String layoutProperty = TiConvert.toString(proxy.getProperty(TiC.PROPERTY_LAYOUT));
				if (layoutProperty.equals(TiC.LAYOUT_HORIZONTAL)) {
					arrangement = LayoutArrangement.HORIZONTAL;
				} else if (layoutProperty.equals(TiC.LAYOUT_VERTICAL)) {
					arrangement = LayoutArrangement.VERTICAL;
				}
			}
			setNativeView(new TiCompositeLayout(proxy.getActivity(), arrangement));
		}

		@Override
		public void processProperties(KrollDict d)
		{
			super.processProperties(d);
		}
}


	// Constructor
	public Box2dWorldProxy()
	{
		super();
		
	//	synchronized(this)
		{
			
			Vector2 gravity = new Vector2(0.0f, -9.81f);
			theWorld = new com.badlogic.gdx.physics.box2d.World(gravity, false);
			theWorld.setContinuousPhysics(true);
		Log.d(LCAT, "printing gravity/world: " + theWorld);
			
			/*
			if (contactListener)
			{
				theWorld->SetContactListener(contactListener);
			}
			*/
		}
	}

	@Override
	public TiUIView createView(Activity activity)
	{
		Box2dWorld view = new Box2dWorld(this);
		worldView = view;
		view.getLayoutParams().autoFillsHeight = true;
		view.getLayoutParams().autoFillsWidth = true;
		return view;
	}

	// Handle creation options
	@Override
	public void handleCreationDict(KrollDict options)
	{
		super.handleCreationDict(options);
		
		if (options.containsKey("message")) {
			Log.d(LCAT, "example created with message: " + options.get("message"));
		}
	}
	
	protected void addBodyToView(SpriteProxy viewproxy)
	{
//		if (_destroyed==NO)
		{
//			[self _createWorld];
			//worldView.add(viewproxy);
		Log.d(LCAT, "addBodyToView viewproxy: " + viewproxy);
			//this.add(viewproxy);

			SceneProxy scene = (SceneProxy)theSurface.topScene();
			scene.add(viewproxy);
		
		}
	}


	// Methods
	//
	@Kroll.method
	public void start()
	{
		if(null != ticksTimer)
		{
			return;
		}

		// From experience, Android timers like this are terrible and will drift.
		// This should be replaced.
		ticksTimer = new Handler();
		final int delay = (int)(1.0f/60.0f*1000f);//milli seconds

		ticksTimer.postDelayed(new Runnable()
			{
				public void run()
				{
					//do something
					tick();
					synchronized(ticksTimer)
					{
						ticksTimer.postDelayed(this, delay); // milliseconds
					}
				}
			},
			delay
		);
	}
	@Kroll.method
	public void stop()
	{
		synchronized(ticksTimer)
		{
			ticksTimer = null;
		}
	}

	private void tick()
	{
//		Log.d(LCAT, "tick : " );
		
		if(null != theWorld)
		{
			synchronized(this)
			{
//		Log.d(LCAT, "tick synchronized: " );
				
				final int velocityIterations = 8;
				final int positionIterations = 1;
		
				// Instruct the world to perform a single step of simulation. It is
				// generally best to keep the time step and iterations fixed.
				theWorld.step(1.0f/60.0f, velocityIterations, positionIterations);

		//CGSize size = [[surface view] bounds].size;
		Log.d(LCAT, "tick theWorld: " + theWorld );
		
		//Iterate over the bodies in the physics world
		Iterator<Body> body_iter = theWorld.getBodies();
		Log.d(LCAT, "tick body_iter: "+ body_iter );
		
		int surface_height = theSurface.getView().getGameViewHeight();
		
		while(body_iter.hasNext())
		{
			Body current_body = body_iter.next();
		Log.d(LCAT, "current_body: " + current_body );
			
			Object user_data = current_body.getUserData();
		Log.d(LCAT, "user_data: " + user_data );
			
			if(null != user_data)
			{
				if(user_data instanceof BodyProxy) 
				{
					BodyProxy body_proxy = (BodyProxy)user_data;
					PlatinoSprite one_view = body_proxy.getViewproxy().getSprite();

				//	TiUIView ti_physical_view = body_proxy.getViewproxy().getOrCreateView();
				//	View native_physical_view = ti_physical_view.getNativeView();

					Vector2 position = current_body.getPosition();
		
					float new_center_x = position.x * PTM_RATIO;
//					int surface_height = this.getOrCreateView().getNativeView().getHeight();
					float new_center_y = surface_height - position.y * PTM_RATIO;

					// is there a moveCenter like iOS?
					one_view.move(new_center_x, new_center_y);
					one_view.rotate((float)(java.lang.Math.toDegrees(current_body.getAngle())));

					/*

					int physical_width = native_physical_view.getWidth();
					int physical_height = native_physical_view.getHeight();
					int new_left = (int)(new_center_x - physical_width/2.0f);
					int new_bottom = (int)(new_center_y - physical_height/2.0f);
					native_physical_view.setLeft(new_left);
					native_physical_view.setBottom(new_bottom);

		Log.d(LCAT, "tick new_left: " + new_left + " new_bottom " + new_bottom);
					*/
					/*
		int physical_left =  native_physical_view.getLeft();
		int physical_bottom =  native_physical_view.getBottom();
		int physical_center_x = (physical_width/2)+physical_left;
		int physical_center_y = (physical_height/2)+physical_bottom;

		int box_width = physical_width/PTM_RATIO/2;
		int box_height = physical_height/PTM_RATIO/2;
*/
					// Skip rotation for now. It's not going to work right on Android views anyway.
				}

			}
			/*
			if (ud != NULL && sizeof(ud)==sizeof(id) && [(id)ud isKindOfClass:[TiBox2dBodyProxy class]])
			{
				UIView *oneView = [[(TiBox2dBodyProxy *)ud viewproxy] view];
				
				// y Position subtracted because of flipped coordinate system
				CGPoint newCenter = CGPointMake(b->GetPosition().x * PTM_RATIO,
												size.height - b->GetPosition().y * PTM_RATIO);
				oneView.center = newCenter;
				
				CGAffineTransform transform = CGAffineTransformMakeRotation(- b->GetAngle());
				
				oneView.transform = transform;
			}
			*/
		}
				
			}
		}
	}
	@Kroll.method
	public BodyProxy addBody(Object[] args)
	{
		synchronized(this)
		{

		SpriteProxy viewproxy = (SpriteProxy)args[0];
		HashMap props = (HashMap)args[1];
		Log.d(LCAT, "printing viewproxy: " + viewproxy);
			
		Log.d(LCAT, "printing props: " + props);

		
		/*
		Thread t = new Thread("Thread1") {
        @Override
        public void run() {
            // some code #2
            runOnUiThread(new Runnable() {
                public void run() {
                    // some code #3 (that needs to be ran in UI thread)
		addBodyToView(viewproxy);

                }
            });

        }
    };
    t.start();
    t.join();
*/
		/*
		   Activity_Name.this.runOnUiThread(new Runnable() {

            @Override
            public void run() {
                // your stuff to update the UI

            }
        });
*/
		addBodyToView(viewproxy);

		PlatinoSprite ti_physical_view = viewproxy.getSprite();
		/*
//		TiUIView ti_physical_view = viewproxy.getOrCreateView();
		Log.d(LCAT, "printing ti_physical_view: " + ti_physical_view);
		
		View native_physical_view = ti_physical_view.getNativeView();
		Log.d(LCAT, "printing native_physical_view: " + native_physical_view);
		
		int physical_width = native_physical_view.getWidth();
		int physical_height = native_physical_view.getHeight();
		int physical_left =  native_physical_view.getLeft();
		int physical_bottom =  native_physical_view.getBottom();
		int physical_center_x = (physical_width/2)+physical_left;
		int physical_center_y = (physical_height/2)+physical_bottom;
*/

		float physical_width = ti_physical_view.getWidth();
		float physical_height = ti_physical_view.getHeight();

		float physical_center_x = ti_physical_view.getCenterX();
		float physical_center_y = ti_physical_view.getCenterY();
		
				
		float box_width = physical_width/PTM_RATIO/2.0f;
		float box_height = physical_height/PTM_RATIO/2.0f;


//		Log.d(LCAT, "printing worldView: " + worldView);
//		Log.d(LCAT, "printing physical_left: " + physical_left);
//		Log.d(LCAT, "printing physical_bottom: " + physical_bottom);
		Log.d(LCAT, "printing box_width: " + box_width);
		Log.d(LCAT, "printing box_height: " + box_height);

	//	int surface_height = theSurface.getOrCreateView().getNativeView().getHeight();
		float surface_height = theSurface.getView().getGameViewHeight();
//		int surface_height = worldView.getNativeView().getHeight();

		
		    // if GameView height is not yet set so we assume default size
		if (surface_height == 0)
		{
			/*
        NSInteger orientation = [surface.orientation intValue];
        if (orientation == UIInterfaceOrientationLandscapeLeft || orientation == UIInterfaceOrientationLandscapeRight) {
            if (UIGraphicsBeginImageContextWithOptions != NULL) {
                height = 640;
            } else {
                height = 320;
            }
        } else {
            if (UIGraphicsBeginImageContextWithOptions != NULL) {
                height = 960;
            } else {
                height = 480;
            }
        }
		*/
			
		surface_height = 960.0f;
    }
		Log.d(LCAT, "surface_height: " + surface_height);

		// Define the dynamic body.
		BodyDef body_def = new BodyDef();
		body_def.type = BodyDef.BodyType.DynamicBody;
	
		body_def.position = new Vector2(physical_center_x/PTM_RATIO, (surface_height - physical_center_y)/PTM_RATIO);
		body_def.angle = (float)(java.lang.Math.toRadians(ti_physical_view.getAngle()));
	
    
		if(null==listOfBodies)
		{
			listOfBodies = new ArrayList();
		}
	
//	TiBox2dBodyProxy *bp = nil;
box_width=50;
box_height=50;
	if(null != theWorld && box_width > 0 && box_height > 0)
	{

		// Tell the physics world to create the body
		Body the_body = theWorld.createBody(body_def);
		// Define the dynamic body fixture.
		FixtureDef fixture_def = new FixtureDef();
		float radius = 0;
		Log.d(LCAT, "createBody: radius " + radius);
		
		Object radius_object = props.get("radius");
		if(null != radius_object)
		{
			radius = TiConvert.toFloat(radius_object);
		}


		if (radius > 0)
		{
			CircleShape circle = new CircleShape();
			circle.setRadius(radius / PTM_RATIO);
			fixture_def.shape = circle;
		}
		else
		{
			// Define another box shape for our dynamic body.
			
			PolygonShape shape = new PolygonShape();
			Object[] shape_objects = (Object[])props.get("shape");
			if(null != shape_objects)
			{
                int count = shape_objects.length;
				Vector2[] vertices = new Vector2[count/2];
                int x = 0;
                for (int c = 0; c < count; c+=2)
                {
                    vertices[x++] = new Vector2(
						TiConvert.toFloat(shape_objects[c])/PTM_RATIO,
						TiConvert.toFloat(shape_objects[c+1])/PTM_RATIO
					);

                }
                shape.set(vertices);
			}
            else
            {
                shape.setAsBox(box_width, box_height);
            }
			fixture_def.shape = shape;
		}

		float density = 3.0f;
		Object density_object = props.get("density");
		if(null != density_object)
		{
			density = TiConvert.toFloat(density_object);
		}
		fixture_def.density = density;

		float friction = 0.3f;
		Object friction_object = props.get("friction");
		if(null != friction_object)
		{
			friction = TiConvert.toFloat(friction_object);
		}
		fixture_def.friction = friction;
		
		float restitution = 0.5f;
		Object restitution_object = props.get("restitution");
		if(null != restitution_object)
		{
			restitution = TiConvert.toFloat(restitution_object);
		}
		fixture_def.restitution = restitution;

		the_body.createFixture(fixture_def);

		Object body_object = props.get("type");
		String body_string = TiConvert.toString(restitution_object, "dynamic");
		
		if(body_string.equals("dynamic"))
		{
			the_body.setType(BodyDef.BodyType.DynamicBody);		
		}
		else if(body_string.equals("static"))
		{
			the_body.setType(BodyDef.BodyType.StaticBody);		
		}
		else if(body_string.equals("kinematic"))
		{
			the_body.setType(BodyDef.BodyType.KinematicBody);		
		}

		BodyProxy body_proxy = new BodyProxy(the_body, viewproxy, theSurface);
		the_body.setUserData(body_proxy);
		
			/*
			// we abuse the tag property as pointer to the physical body
		physicalView.tag = (int)body;
		
		bp = [[TiBox2dBodyProxy alloc] initWithBody:body viewproxy:viewproxy pageContext:[self executionContext]];
		
		body->SetUserData(bp);
	
	[lock unlock];
	
	return bp;
		*/
		return body_proxy;
		}
		}
		return null;
	}




	@Kroll.method
	public void printMessage(String message)
	{
		Log.d(LCAT, "printing message: " + message);
	}


	@Kroll.getProperty @Kroll.method
	public String getMessage()
	{
        return "Hello World from my module";
	}

	@Kroll.setProperty @Kroll.method
	public void setMessage(String message)
	{
	    Log.d(LCAT, "Tried setting module message to: " + message);
	}



	@Kroll.getProperty @Kroll.method
	public GameViewProxy getSurface()
	{
	    Log.d(LCAT, "getSurface: " + theSurface);
		
        return theSurface;
	}

	@Kroll.setProperty @Kroll.method
	public void setSurface(GameViewProxy surface)
	{
		theSurface = surface;

	    Log.d(LCAT, "setSurface: " + theSurface);

	}

}
